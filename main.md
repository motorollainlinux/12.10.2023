## Сортировка выбором
### Работа памяти
Память представляет собой нечто вроде огромного шкафа с множеством ящиков, и у каждого 
ящика есть адрес.<br>
*пример: feOffeeb - адрес ячейки памяти.* <br>
Каждый раз, когда вы хотите сохранить в памяти отдельное значение, вы запрашиваете у компьютера место в памяти, а он выдает адрес для сохранения значения.
Если же вам понадобится сохранить несколько элементов, это можно сделать двумя основными способами: воспользоваться массивом или списком.
### Массивы и связанные списки
При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом).
В случае, усли мы хотим добавить новый элемнт массива, а все ячейки уже заняты, придется запросить у компьютера другой блок памяти, в котором поместятся все элементы, а потом переместить все элементы массива туда.
Если свободного места нет и вам каждый раз приходится перемещаться в новую область в памяти, операция добавления нового элемента будет выполняться очень медленно. 
Простейшее решение - «бронирование мест»: даже если список состоит всего из 3 задач, вы запрашиваете у компьютера место на 1О позиций.
Это неплохое обходное решение, но у него есть пара недостатков: 
+ Лишнее место может не понадобиться, и тогда память будет расходоваться неэффективно. Вы ее не используете, однако никто другой ее использовать тоже не может. 
+ Если в список будет добавлено более 10 задач, перемещаться все равно придется.
В общем, прием неплохой, но его нельзя назвать идеальным. Связанные списки решают проблему добавления новых элементов. 
#### Связанные списки
При использовании связанного списка элементы могут размещаться где угодно в памяти. В каждом элементе хранится адрес следующего емента списка.
Таким образом, набор произвольных адресов памяти объединяется в цепочку. 
Со связанными списками ничего перемещать в памяти не нужно. Также сама собой решается другая проблема:
Допустим, вы пытаетесь найти для массива блок на 1О ООО элементов.
В памяти можно найти место для 1О ООО элементов, но только не смежное.
Для массива не хватает места.
#### Массивы 
У свазянных списков есть одна проблемма: допустим, вы хотите получить последний элемент связанного списка. Просто прочитать нужное значение не удастся, потому что вы не знаете, по какому адресу оно хранится. 
Вместо этого придется сначала обратиться к элементу № 1 и узнать адрес элемента № 2, потомобратиться к элементу № 2 и узнать адрес элемента № 3". и так далее, пока не доберетесь до последнего элемента. 
Связанные списки отлично подходят в тех ситуациях, когда данные должны читаться последовательно: сначала вы читаете один элемент, по адресу переходите к следующему ементу и т. д. 
Но если вы намерены прыгать по списку туда-сюда, держитесь подальше от связанных списков.<br>
С массивами дело обстоит совершенно иначе. Работая с массивом, вы заранее знаете адрес каждого его элемента. Допустим, массив содержит пять элементов и вы знаете, что он начинается с адреса 00.<br>
Массивы прекрасно подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно.
В связанном списке нты не хранятся рядом друг с другом, поэтому мгновенно определить по ицию i-го лемента в памяти невозможно.
#### Удаление 
Для удаления элементов список лучше подходит для этой операции, потому что в нем достаточно изменить указатель в предыдущем элементе.
В массиве при удалении элемента все последующие элементы нужно будет сдвинуть вверх. В отличие от вставки удаление возможно всегда. 
Попытка вставки может быть неудачной, если в памяти не осталось свободного места. С удалением подобных проблем не бывает.
Заметим, что вставка и удаление выполняются за время 0(1) только в том случае, если вы можете мгновенно получить доступ к удаляемому элементу.
На практике обычно сохраняются ссылки на первый и последний элементы связанного списка, поэтому время удаления этих элементов составит всего 0(1).
### Сортировка выбором
Вы хотите отсортировать список по убыванию счетчика, Одно из возможных решений - пройти по списку и найти элемент с наибольшим номером. Этот элемет добавляется в новый список. 
Потом то же самое происходит со следующим элеметом.
Продолжая действовать так, мы получаем отсортированный список. 
А теперь попробуем оценить происходящее с точки зрения теории вычислений и посмотрим, сколько времени будут занимать операции. Напомним, что время О(п) означает, что вы по одному разу обращаетесь к каждому элементу списка. 
Например, при: простом поиске по списку исполнителей каждый исполнитель будет проверен один раз. 
Алгоритмы сортировки очень полезны. Например, теперь вы можете отсортировать: 
+ имена в телефонной книге; 
+ даты путешествий; 
+ сообщения электронной почты (от новых к старым).
Алгоритм сортировки выбором легко объясняется, но медленно работает. 
Быстрая сортировка - эффективный алгоритм сортировки, который выполняется за время О(п log п).
#### Пример кода 
Напишем функцию для поиска наименьшего элемента массива:
```
def find Smallest(a r r): 
  smallest = arr[0] 
  smallest_index = 0 
  for i in range(l, len(arr)): 
    if arr[i] < smallest: 
      smallest = arr[i] 
      smallest_index = i 
  return smallest_index
```
Теперь на основе этой функции можно написать функцию сортировки выбором:
```
def selectionSort(arr): 
  newArr = [] 
  for i in range(len(arr)): 
    smallest = indSmallest(arr) 
    newArr.append(arr.pop(smallest)) 
  return newArr

print selectionSort([S, З, 6, 2, 10])
```
